---
{"dg-publish":true,"permalink":"/notion/theoretical-knowledge/computer-science/artificial-intelligence/concept/sign-magnitude-representation-one-s-complement-and-two-s-complement/"}
---

在计算机科学和数字电路中，"补码" (Complement Code) 是一种表示有符号整数（正数和负数）的方法。它解决了早期表示方法（如原码、反码）在算术运算上的一些复杂性和问题。

我们通常说的“1补码”和“2补码”实际上是指 **“反码 (One's Complement)”** 和 **“补码 (Two's Complement)”**。

---

### 1. 原码 (Sign-Magnitude Representation)

在介绍反码和补码之前，先简单说一下原码。
**原码：** 用最高位表示符号（0代表正数，1代表负数），其余位表示数值的绝对值。
*   **优点：** 直观，易于理解。
*   **缺点：**
    1.  **有两个零：** `+0` (0000) 和 `-0` (1000)（以4位为例）。这导致判断零的逻辑更复杂。
    2.  **加减法复杂：** 进行加减运算时，需要先判断符号，再根据符号决定是做加法还是减法，最后确定结果的符号。

---

### 2. 反码 (One's Complement) - "1补码"

**定义：**
*   **正数：** 它的反码就是其原码本身。
*   **负数：** 它的反码是在其原码的基础上，**符号位不变，其他所有位取反**（0变1，1变0）。
    *   例如，对于 4 位二进制数：
        *   `+5` 的原码是 `0101`，反码也是 `0101`。
        *   `-5` 的原码是 `1101`。取反后（符号位不变），反码是 `1010`。

**特点：**
*   **有两个零：** `+0` (0000) 和 `-0` (1111)（以4位为例）。
*   **加法规则：** 可以直接进行加法运算，但如果最高位有进位（即结果溢出到符号位之外），需要将这个进位加到结果的最低位（这被称为“循环进位”或“末位进位”）。
*   **减法：** `A - B` 可以转换为 `A + (-B的反码)`。

**为什么叫 "One's Complement" (反码)？**
因为一个数的反码加上它本身，所有位都变成1（假设不考虑符号位）。例如，`0101 (+5)` 和 `1010 (-5的反码)`。`0101 + 1010 = 1111`。在数学上，这可以理解为对 `2^n - 1` 的“补足”，即 `X + X' = 2^n - 1`。

---

### 3. 补码 (Two's Complement) - "2补码"

**定义：**
*   **正数：** 它的补码就是其原码本身。
*   **负数：** 它的补码是在其反码的基础上，**末位加 1**。
    *   **方法一：** 负数的原码 -> 符号位不变，其他位取反 -> 结果末位加1。
    *   **方法二：** 从右向左找到第一个 `1`，这个 `1` 和它右边的所有位保持不变。这个 `1` 左边的所有位都取反。
    *   例如，对于 4 位二进制数：
        *   `+5` 的原码是 `0101`，补码也是 `0101`。
        *   `-5` 的原码是 `1101`。
            *   方法一：反码 `1010`，末位加1 -> `1011`。所以 `-5` 的补码是 `1011`。
            *   方法二：`1101`。从右向左第一个 `1` 在最低位。保持 `1`，它左边的 `110` 取反变成 `001`。组合起来得到 `0011`。**注意：这里方法二是对正数求负数补码，或对负数求正数补码时使用的。更常用的是从原码或反码转换。**

**核心优势：**
1.  **唯一的零：** 只有 `0000` 表示 `0`。这解决了原码和反码的双零问题。
2.  **统一的加减法：** 所有的加减运算都可以通过加法来完成，无需额外处理符号位。
    *   `A - B` 等同于 `A + (-B的补码)`。
    *   例如，`5 - 3` (4位)：
        *   `+5` 的补码是 `0101`
        *   `+3` 的补码是 `0011`
        *   `-3` 的补码是：`0011` (原码) -> `1100` (反码) -> `1101` (补码)
        *   `0101 + 1101 = 10010`。在 4 位系统中，最高位的进位 `1` 被舍弃，结果是 `0010`，即 `+2`，正确！
3.  **表示范围不对称：** 对于 n 位二进制数，补码可以表示 `-(2^(n-1))` 到 `(2^(n-1) - 1)` 的范围。例如，4 位可以表示 `-8` 到 `+7`。这是因为少了一个 `0` 的表示，所以负数可以多表示一个。

**为什么叫 "Two's Complement" (补码)？**
这是因为一个负数的补码加上它本身，结果是 `2^n`（在模 `2^n` 意义下为 `0`），这在数学上被称为对 `2^n` 的“补足”。
*   假设有 n 位二进制数，其能表示的最大范围是 `2^n`。
*   一个正数 `X` 的负数补码 `-X_补码`，实际上是 `2^n - X`。
*   例如，在 4 位系统中，`n=4`，`2^n = 16`。
    *   `-5` 的补码是 `1011` (二进制的 `11`)。
    *   我们知道 `16 - 5 = 11`。这个 `11` 就是 `-5` 在 4 位补码中的表示。
    *   当进行 `X + (-X)` 运算时，实际上是 `X + (2^n - X) = 2^n`。在 n 位系统中，`2^n` 恰好是 `1` 后面跟 `n` 个 `0`（例如 `10000` for `n=4`）。这个最高位的 `1` 会被截断，剩下的 `n` 个 `0` 就是 `0`。这完美地实现了加法运算的统一。

这种“补足”的概念使得处理器在进行加减法时，无论数字是正数还是负数，都只进行简单的二进制加法，最高位溢出就舍弃，从而大大简化了硬件设计。这是现代计算机普遍采用补码表示有符号整数的原因。