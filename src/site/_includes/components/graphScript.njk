<script>
    async function fetchGraphData() {
        const graphData = await fetch('/graph.json').then(res => res.json());
        const fullGraphData  = filterFullGraphData(graphData);
        return {graphData, fullGraphData}
    }

    function getNextLevelNeighbours(existing, remaining) {
        const keys = Object.values(existing).map((n) => n.neighbors).flat();
        const n_remaining = Object.keys(remaining).reduce((acc, key) => {
                if (keys.indexOf(key) != -1) {
                    if (!remaining[key].hide) {
                        existing[key] = remaining[key];
                    }
                } else {
                    acc[key] = remaining[key];
                }
                return acc;
            }, {});
        return existing, n_remaining;
    }

    function filterLocalGraphData(graphData, depth) {
        if (graphData == null) {
            return null;
        }
        let remaining = JSON.parse(JSON.stringify(graphData.nodes));
        let links = JSON.parse(JSON.stringify(graphData.links));
        let currentLink = decodeURI(window.location.pathname);
        let currentNode = remaining[currentLink] || Object.values(remaining).find((v) => v.home);
        delete remaining[currentNode.url];
        if (!currentNode.home) {
            let home = Object.values(remaining).find((v) => v.home);
            delete remaining[home.url];
        }
        currentNode.current = true;
        let existing = {};
        existing[currentNode.url] = currentNode;
        for (let i = 0; i < depth; i++) {
            existing, remaining = getNextLevelNeighbours(existing, remaining);
        }
        nodes = Object.values(existing);
        if (!currentNode.home) {
            nodes = nodes.filter(n => !n.home);
        }
        let ids = nodes.map((n) => n.id);
        return {
            nodes,
            links: links.filter(function (con) {
                return ids.indexOf(con.target) > -1 && ids.indexOf(con.source) > -1;
            }),
        }
    }

    function getCssVar(variable) {return getComputedStyle(document.body).getPropertyValue(variable)}

    function htmlDecode(input) {
        var doc = new DOMParser().parseFromString(input, "text/html");
        return doc.documentElement.textContent;
    }

    function renderGraph(graphData, id, delay, fullScreen) {
        if (graphData == null) {
            return;
        }
        const el = document.getElementById(id);
        width = el.offsetWidth;
        height = el.offsetHeight;
        const highlightNodes = new Set();
        let hoverNode = null;
        const color = getCssVar("--graph-main");
        const mutedColor = getCssVar("--graph-muted");
        const folderColor = getCssVar("--text-muted"); // 文件夹颜色
        
        let Graph = ForceGraph()
        (el)
            .graphData(graphData)
            .nodeId('id')
            .nodeLabel('title')
            .linkSource('source')
            .linkTarget('target')
            .d3AlphaDecay(0.10)
            .width(width)
            .height(height)
            .linkDirectionalArrowLength(2)
            .linkDirectionalArrowRelPos(0.5)
            .autoPauseRedraw(false)
            .linkColor((link) => {
                // 如果连接涉及文件夹，使用虚线样式
                if (link.isFolder || (graphData.nodes.find(n => n.id === link.source)?.isFolder) || 
                    (graphData.nodes.find(n => n.id === link.target)?.isFolder)) {
                    return mutedColor;
                }
                
                if (hoverNode == null) {
                    return color;
                }
                if (link.source.id == hoverNode.id || link.target.id == hoverNode.id) {
                    return color;
                } else {
                    return mutedColor;
                }
            })
            .linkCanvasObject((link, ctx) => {
                const start = link.source;
                const end = link.target;
                
                // 检查是否是文件夹连接
                const isFolderLink = start.isFolder || end.isFolder;
                
                if (isFolderLink) {
                    // 绘制虚线
                    ctx.save();
                    ctx.strokeStyle = mutedColor;
                    ctx.lineWidth = 1;
                    ctx.setLineDash([3, 3]); // 虚线样式
                    ctx.beginPath();
                    ctx.moveTo(start.x, start.y);
                    ctx.lineTo(end.x, end.y);
                    ctx.stroke();
                    ctx.restore();
                    return true; // 返回true表示自定义绘制完成
                }
                return false; // 使用默认绘制
            })
            .nodeCanvasObject((node, ctx) => {
                const numberOfNeighbours = (node.neighbors && node.neighbors.length) || 2;
                const nodeR = Math.min(7, Math.max(numberOfNeighbours / 2, 2));
                
                ctx.beginPath();
                ctx.arc(node.x, node.y, nodeR, 0, 2 * Math.PI, false);
                
                // 根据节点类型选择颜色
                let fillColor;
                if (node.isFolder) {
                    fillColor = folderColor;
                } else if (hoverNode == null) {
                    fillColor = color;
                } else {
                    if (node == hoverNode || highlightNodes.has(node.url)) {
                        fillColor = color;
                    } else {
                        fillColor = mutedColor;
                    }
                }
                ctx.fillStyle = fillColor;
                ctx.fill();
                
                // 文件夹节点使用方形边框
                if (node.isFolder) {
                    ctx.beginPath();
                    const size = nodeR * 1.2;
                    ctx.rect(node.x - size/2, node.y - size/2, size, size);
                    ctx.strokeStyle = folderColor;
                    ctx.lineWidth = 1;
                    ctx.stroke();
                } else if (node.current) {
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, nodeR + 1, 0, 2 * Math.PI, false);
                    ctx.lineWidth = 0.5;
                    ctx.strokeStyle = color;
                    ctx.stroke();
                }

                const label = htmlDecode(node.title)
                const fontSize = node.isFolder ? 3.0 : 3.5; // 文件夹字体稍小
                ctx.font = `${fontSize}px Sans-Serif`;
                ctx.fillStyle = node.isFolder ? folderColor : fillColor;

                ctx.textAlign = 'center';
                ctx.textBaseline = 'top';
                ctx.fillText(label, node.x, node.y + nodeR + 2);
            })
            .onNodeClick(node => {
                // 只有非文件夹节点才能点击跳转
                if (!node.isFolder && node.url) {
                    window.location = node.url;
                }
            })
            .onNodeHover(node => {
                highlightNodes.clear();
                if (node) {
                    highlightNodes.add(node);
                    if (node.neighbors) {
                        node.neighbors.forEach(neighbor => highlightNodes.add(neighbor));
                    }
                }
                hoverNode = node || null;
            });
            if (fullScreen || (delay != null && graphData.nodes.length > 4)) {
                setTimeout(() => {
                    Graph.zoomToFit(5, 75);
                }, delay || 200);
            }
        return Graph;
    }

    function renderLocalGraph(graphData, depth, fullScreen) {
        if (window.graph){
            window.graph._destructor();
        }
        const data = filterLocalGraphData(graphData, depth);
        return renderGraph(data, 'link-graph', null, fullScreen);
    }

    function filterFullGraphData(graphData) {
        if (graphData == null) {
            return null;
        }
        graphData = JSON.parse(JSON.stringify(graphData));
        const hiddens = Object.values(graphData.nodes).filter((n) => n.hide).map((n) => n.id);
        
        // 创建文件夹节点映射
        const folderNodes = new Map();
        const enhancedNodes = [];
        const enhancedLinks = [];
        
        // 处理现有节点并创建文件夹结构
        Object.values(graphData.nodes).forEach(node => {
            if (!node.hide) {
                enhancedNodes.push(node);
                
                // 从节点路径提取文件夹层级
                if (node.url && node.url !== '/') {
                    const pathParts = node.url.split('/').filter(part => part);
                    let currentPath = '';
                    
                    for (let i = 0; i < pathParts.length - 1; i++) {
                        const folderName = pathParts[i];
                        const parentPath = currentPath;
                        currentPath += '/' + folderName;
                        
                        if (!folderNodes.has(currentPath)) {
                            const folderId = `folder-${currentPath.replace(/\//g, '-')}`;
                            folderNodes.set(currentPath, {
                                id: folderId,
                                title: folderName,
                                isFolder: true,
                                path: currentPath,
                                neighbors: []
                            });
                            enhancedNodes.push(folderNodes.get(currentPath));
                        }
                        
                        // 连接父文件夹和子文件夹
                        if (parentPath && folderNodes.has(parentPath)) {
                            enhancedLinks.push({
                                source: folderNodes.get(parentPath).id,
                                target: folderNodes.get(currentPath).id,
                                isFolder: true
                            });
                        }
                    }
                    
                    // 连接最后一级文件夹和文件
                    if (currentPath && folderNodes.has(currentPath)) {
                        enhancedLinks.push({
                            source: folderNodes.get(currentPath).id,
                            target: node.id,
                            isFolder: true
                        });
                    }
                }
            }
        });
        
        // 添加原有的文章间连接
        const originalLinks = graphData.links.filter((l) => 
            hiddens.indexOf(l.source) == -1 && hiddens.indexOf(l.target) == -1
        );
        
        return {
            nodes: enhancedNodes,
            links: [...originalLinks, ...enhancedLinks]
        };
    }

    function openFullGraph(fullGraphData) {
        lucide.createIcons({
                attrs: {
                    class: ["svg-icon"]
                }
            });
        return renderGraph(fullGraphData, "full-graph-container", 200, false);;
    }

    function closefullGraph(fullGraph) {
        if (fullGraph) {
            fullGraph._destructor();
        }
        return null;
    }
</script>
<div  x-init="{graphData, fullGraphData} = await fetchGraphData();" x-data="{ graphData: null, depth: 1, graph: null, fullGraph: null, showFullGraph: false, fullScreen: false, fullGraphData: null}" id="graph-component" x-bind:class="fullScreen ? 'graph graph-fs' : 'graph'" v-scope>
    <div class="graph-title-container">
        <div id="graph-controls">
                <div class="ctrl-right">
                    <span id="local-graph-btn" x-on:click="window.graph = renderLocalGraph(graphData, 1, fullScreen)" title="当前文章联系"><i  icon-name="target" aria-hidden="true"></i></span>
                    <span id="global-graph-btn" x-on:click="showFullGraph = true; setTimeout(() => {fullGraph = openFullGraph(fullGraphData)}, 100)" title="全局联系"><i  icon-name="globe" aria-hidden="true"></i></span>
                    <span  id="graph-fs-btn"  x-on:click="fullScreen = !fullScreen; setTimeout(() => {window.graph = renderLocalGraph(graphData, depth, fullScreen)}, 100)" title="切换全屏"><i  icon-name="expand" aria-hidden="true"></i></span>
                </div>
        </div>
    </div>
    <div x-effect="window.graph = renderLocalGraph(graphData, depth, fullScreen)" id="link-graph" ></div>
    <div x-show="showFullGraph" id="full-graph" x-bind:class="showFullGraph ? 'show' : ''" style="display: none;">
        <span id="full-graph-close" x-on:click="fullGraph = closefullGraph(fullGraph); showFullGraph = false;"><i icon-name="x" aria-hidden="true"></i></span>
        <div id="full-graph-container"></div>
    </div>
</div>